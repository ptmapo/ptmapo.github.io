{"pages":[{"title":"","text":"$(function () { var arr = \"img/show/20200605111322.jpg,img/show/20200605111451.jpg,img/show/20200605111516.jpg,img/show/20200605111523.jpg,img/show/20200605111529.jpg,img/show/20200605111533.jpg,img/show/20200605111537.jpg,img/show/20200605111542.jpg,img/show/20200605111552.jpg,img/show/20200605111556.jpg,img/show/20200605111601.jpg,img/show/20200605111613.jpg,img/show/20200605111636.jpg,img/show/20200605111643.jpg,img/show/20200605111648.jpg,img/show/20200605111700.jpg,img/show/20200605111705.jpg,img/show/20200605111710.jpg,img/show/20200605111714.jpg,img/show/20200605111729.jpg,img/show/20200605111737.jpg,img/show/20200605111746.jpg,img/show/20200605111750.jpg,img/show/20200605111757.jpg,img/show/20200605111803.jpg,img/show/20200605111810.jpg,img/show/20200605111814.jpg,img/show/20200605111836.jpg,img/show/20200605111843.jpg,img/show/20200605111849.jpg,img/show/20200605111857.jpg,img/show/20200605111910.jpg,img/show/20200605111931.jpg,img/show/20200605111937.jpg,img/show/20200605111942.jpg,img/show/20200605111945.jpg,img/show/20200605111955.jpg,img/show/20200605111959.jpg,img/show/20200605112007.jpg,img/show/20200605112023.jpg,img/show/20200605112036.jpg,img/show/20200605112043.jpg,img/show/20200605112052.jpg,img/show/20200605112109.jpg,img/show/20200605112118.jpg,img/show/20200605112142.jpg,img/show/20200605112202.jpg,img/show/20200605112231.jpg,img/show/20200605112243.jpg,img/show/20200605112248.jpg,img/show/20200605112302.jpg,img/show/20200605112311.jpg,img/show/20200605112346.jpg,img/show/20200605112351.jpg,img/show/20200605112355.jpg,img/show/20200605112400.jpg,img/show/20200605112404.jpg,img/show/20200605112409.jpg,img/show/20200605112416.jpg,img/show/20200605112424.jpg,img/show/20200605112427.jpg,img/show/20200605112438.jpg,img/show/20200605112443.jpg,img/show/20200605112453.jpg,img/show/20200605112503.jpg,img/show/20200605112507.jpg,img/show/20200605112512.jpg,img/show/20200605112531.jpg,img/show/20200605112539.jpg,img/show/20200605112545.jpg,img/show/20200605112549.jpg,img/show/20200605112555.jpg,img/show/20200605112559.jpg,img/show/20200605112602.jpg,img/show/20200605112615.jpg,img/show/20200605112621.jpg,img/show/20200605112628.jpg,img/show/20200605112632.jpg,img/show/20200605112641.jpg,img/show/20200605112646.jpg,img/show/20200605112651.jpg,img/show/20200605112656.jpg,img/show/20200605112705.jpg,img/show/20200605112709.jpg,img/show/20200605112714.jpg,img/show/20200605112719.jpg,img/show/20200605112725.jpg,img/show/20200605112730.jpg,img/show/20200605112736.jpg,img/show/20200605112740.jpg,img/show/20200605112743.jpg,img/show/20200605112750.jpg,img/show/20200605112752.jpg,img/show/20200605112756.jpg,img/show/20200605112824.jpg,img/show/20200605112827.jpg,img/show/20200605112832.jpg,img/show/20200605112838.jpg,img/show/20200605112843.jpg,img/show/20200605112848.jpg,img/show/20200605112853.jpg,img/show/20200605112859.jpg,img/show/20200605112904.jpg,img/show/20200605112909.jpg,img/show/20200605112912.jpg,img/show/20200605112933.jpg,img/show/20200605112938.jpg,img/show/20200605112947.jpg,img/show/20200605112957.jpg,img/show/20200605113001.jpg,img/show/20200605113006.jpg,img/show/20200605113011.jpg,img/show/20200605113016.jpg,img/show/20200605113025.jpg,img/show/20200605113034.jpg,img/show/20200605113038.jpg,img/show/20200605113042.jpg,img/show/20200605113049.jpg,img/show/20200605113055.jpg,img/show/20200605113101.jpg,img/show/20200605113106.jpg,img/show/20200605113114.jpg,img/show/20200605113118.jpg,img/show/20200605113122.jpg,img/show/20200605113132.jpg,img/show/20200605113137.jpg,img/show/20200605113139.jpg,img/show/20200605113142.jpg,img/show/20200605113146.jpg,img/show/20200605113149.jpg,img/show/20200605113156.jpg,img/show/20200605113203.jpg,img/show/20200605113207.jpg,img/show/20200605113211.jpg,img/show/20200605113230.jpg,img/show/20200605113237.jpg,img/show/20200605113242.jpg,img/show/20200605113247.jpg,img/show/20200605113257.jpg,img/show/20200605113303.jpg,img/show/20200605113319.jpg,img/show/20200605113334.jpg,img/show/20200605113338.jpg,img/show/20200605113344.jpg,img/show/20200605113350.jpg,img/show/20200605113403.jpg,img/show/20200605113409.jpg,img/show/20200605113413.jpg,img/show/20200605113417.jpg,img/show/20200605113423.jpg,img/show/20200605113427.jpg,img/show/20200605113432.jpg,img/show/20200605113440.jpg,img/show/20200605113444.jpg,img/show/20200605113448.jpg,img/show/20200605113452.jpg,img/show/20200605113500.jpg,img/show/20200605113504.jpg,img/show/20200605113511.jpg,img/show/20200605113516.jpg,img/show/20200605113521.jpg,img/show/20200605113525.jpg,img/show/20200605113532.jpg,img/show/20200605113535.jpg,img/show/20200605113540.jpg,img/show/20200605113545.jpg,img/show/20200605113551.jpg,img/show/20200605113558.jpg,img/show/20200605113603.png,img/show/20200605113608.png,img/show/20200605113612.png,img/show/20200605113616.png,img/show/20200605113619.png,img/show/20200605113630.png,img/show/20200605113634.png,img/show/20200605113641.png,img/show/20200605113647.png,img/show/20200605113652.png,img/show/20200605113659.png,img/show/20200605113707.png,img/show/20200605113710.png,img/show/20200605113715.png,img/show/20200605113720.png,img/show/20200605113727.png,img/show/20200605113736.png,img/show/20200605113741.png,img/show/20200605113745.png,img/show/20200605113752.png,img/show/20200605113757.png,img/show/20200605113800.png,img/show/20200605113817.png,img/show/20200605113824.png,img/show/20200605113834.png,img/show/20200605113838.png,img/show/20200605113841.png,img/show/20200605113845.png,img/show/20200605113905.png,img/show/20200605113907.png,img/show/20200605113912.png,img/show/20200605113916.png,img/show/20200605113921.png,img/show/20200605113926.png,img/show/20200605113935.png,img/show/20200605113940.png,img/show/20200605113945.png,img/show/20200605113951.png,img/show/20200605113956.png,img/show/20200605114000.png,img/show/20200605114003.png,img/show/20200605114008.png,img/show/20200605114012.png,img/show/20200605114016.png,img/show/20200605114023.png,img/show/20200605114027.png,img/show/20200605114033.png,img/show/20200605114041.png,img/show/20200605114050.png,img/show/20200605114107.png,img/show/20200605114123.png,img/show/20200605114140.png,img/show/20200605114148.png,img/show/20200605114152.png,img/show/20200605114156.png,img/show/20200605114204.png,img/show/20200605114207.png,img/show/20200605114211.png,img/show/20200605114214.png,img/show/20200605114218.png,img/show/20200605114223.png,img/show/20200605114226.png,img/show/20200605114238.png,img/show/20200605114245.png,img/show/20200605114250.png,img/show/20200605114304.png,img/show/20200605114315.png,img/show/20200605114319.png,img/show/20200605114324.png,img/show/20200605114329.png,img/show/20200605114334.png,img/show/20200605114337.png,img/show/20200605114345.png,img/show/20200605114350.png,img/show/20200605114359.png,img/show/20200605114406.png,img/show/20200605114410.png,img/show/20200605114413.png,img/show/20200605114421.png,img/show/20200605114425.png,img/show/20200605114429.jpg,img/show/20200605114434.jpg,img/show/20200605114437.jpg,img/show/20200605114440.jpg,img/show/20200605114444.jpg,img/show/20200605114448.jpg,img/show/20200605114454.jpg,img/show/20200605114500.jpg,img/show/20200605114500.jpg\" var paths = arr.split(\",\"); var url =\"https://gitee.com/ptmapo/Img/raw/master/\"; var imgs = $('.ranimg'); for (var i = 0; i","link":"/album/index.html"},{"title":"关于我","text":"---不断优化中--- （优化这方面…特别懒啦，肯定懒的优化啊，，优化是不可能优化的，这辈子都不可能优化的&lt;声嘶力竭&gt;） 如有疑问 请联系Q:37663015","link":"/about/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://raw.githubusercontent.com/ptmapo/Img/master/avatar.png 网站名称：ptmapo 网站地址：1997888.xyz 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"}],"posts":[{"title":"C语言知识小计","text":"C语言知识小计 基础——指针前 1234567#include &lt;stdio.h&gt;int main(){ /* 我的第一个 C 程序 */ printf(\"Hello, World! \\n\"); return 0;} 以上代码为例基础解析 所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。 printf() 用于格式化输出到屏幕。printf() 函数在 “stdio.h” 头文件中声明。 stdio.h 是一个头文件 (标准输入输出头文件) , #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。 return 0; 语句用于表示退出程序。 ​ %占位符的用法 如： printf(“你的名字是 %s , 你的年龄是 %d”,name,age); C语言中的字符串结束标志是\\0 printf的各种输出方式 123456789int main() { printf(\"打印五个字符：%c %c %c %c %c \\n\", 119, 114, 111, 111, 108); printf(\"前面用 填充：%10d\\n\" , 2015); printf(\"前面用 填充：%010d\\n\" , 2015); printf(\"右对齐，保留两位 %10.2f\\n\" ,3.14 ); printf(\"左对齐，保留3位 %-10.3f\\n\" ,3.14 ); printf(\"右对齐，指数形式 %10e\\n\" ,520000.0 ); printf(\"左对齐，指数形式 %-10E\\n\" , 520000.0);} 效果： printf 函数使用 %c 打印 char 类型的字符，使用 %d 和 %u 则打印其对应的 ASCII 码（其中 %d 打印带符号数，%u 打印无符号数）。signed char 和 unsigned char 使用 hh 说明其长度。 数据类型：c中的布尔值是_Bool 一个字节等于八个比特位（1Byte == 8bit），但在c语言中并没有具体定义一个字节等于多少比特位，一个字节被定义为连续比特位，具体大小由实现环境决定。不过通常我们约定俗成是一个字节等于八个比特位。 *C 标准只规定一个数据类型的具体尺寸（其他数据类型都是规定相对范围），那就是char 字符型，C 标准只规定 char 类型占一个字节的空间。 * 整型变量： C 标准规定 short &lt;= int &lt;= long &lt;= long long C 标准规范存储空间最小的是 _Bool 因为只需要容纳0和1两个数即可 为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。 由于默认 int 是 signed 的，即带符号位的整数（可以表示负数），需要用一半的存储空间来存放负数；而 unsigned int 则是完全用于存放正数，因此 unsigned int 能保存2倍于有符号类型的正整数数据。 用 64 位来存放 long long 的值 ，取unsigned long long，它可以表示的最大值是2^64 -1，所以可以最大可以存放一个20位的十进制整数 进制转换举栗请写出以下二进制数（补码）对应的十进制数。 A. 0000 1100 -&gt; 2^3 + 2^2 = 8 + 4 = 12 B. 1100 1100 –&gt; -2^7 + 2^6 + 2^3 + 2^2 = -128 + 64 + 8 + 4 = -52 C. 1010 1010 –&gt; -2^7 + 2^5 + 2^3 + 2 = -128 + 32 + 8 + 2 = -86 D. 1111 1111 -&gt; -2^7 + 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2 + 1 = -1 E. 1000 0000 –&gt; -2^7 = -128 带符号数在内存中以补码的形式保存，正数的补码是其二进制本身，负数则通过对其绝对值的二进制取反加一计算得到（补码） -8 -&gt; 1000 1000 –&gt; 1111 0111 –&gt; 1111 1000 -126 -&gt; -128 + 2 -&gt; 1000 0000 + 0000 0010 -&gt; 1000 0010 对于逻辑与和逻辑或采用短路求值方式。 字符与字符串C语言中，最小的整数类型是char。（虽然 char 是字符类型，但它事实上是用于存放整数，因此属于整数类型。） 标准 ASCII 字符表使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符；数字 09 对应的十六进制 ASCII 值分别是 3039。 大写字母对应的 ASCII 值第 6 位置 1 则变成对应的小写字母，反之亦然。例如：大写字母 A 的二进制 ASCII 值是 0100 0001，对应的小写字母 a 的二进制则是 0110 0001。此规则适用于所有大小写字母的相互转换 一个字符串在内存中占有多少字节？ 字符串的长度加一，因为字符串最后需要加一个‘\\0’字符表示结束 如果用char name[10] = “xiaomu”; 定义字符串；则其变量name在内存中的储存形式是：’x’，’i’，’a’，’o’，’m’，’u’，’\\0’，’\\0’，’\\0’，’\\0’ 声明了10个字节但是只需7个（包括结尾\\0），因此多余的空间用‘\\0’进行填充。如果 scanf_s()教材中的scanf()，在目前Visual Studio版本中已经弃用； scanf_s() 的功能虽然与scanf() 相同，但却比 scanf() 安全，因为 scanf()在读取字符串时不检查边界，可能会造成内存泄露”；而scanf_s() 在读取数据的时候会检查边界，如果输入的数据达到了所请求的内存空间，则不会再读入数据。 运算符求余运算符两边要求均为整形。 赋值运算符的结合性是自右向左的； 为什么a = 0 &amp;&amp; 1 = b;编译会报错？ 少打了一个等号（=），使得表达式先计算逻辑运算符的值为 0 &amp;&amp; 1 结果为假（0），便出现了 0 = b 这样错误的赋值语句（我们无法给一个常数赋值） count != 0 &amp;&amp; sum/count 该表达式使用逻辑与（&amp;&amp;）来确保 sum/count 的除数不为 0。","link":"/2020/06/14/C,C++/C-20200614/"},{"title":"AutoGeneratorCode","text":"MyBatisPlus的AutoGenerator（自动生成代码） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//代码生成器 AutoGenerator autoGenerator = new AutoGenerator(); //全局配置策略 GlobalConfig globalConfig= new GlobalConfig(); //动态获取当前项目的路径 String path= System.getProperty(\"user.dir\"); System.out.println(path); //是否覆盖同名文件 默认是false； globalConfig.setFileOverride(false); //不需要ActiveRecode特性的 请改为false globalConfig.setActiveRecord(true); //xml 二级缓存 globalConfig.setEnableCache(false); //是否在xml文件中定义resultMap标签 globalConfig.setBaseResultMap(true); //是否在xml文件中定义字段列表。 &lt;sql&gt;标签 globalConfig.setBaseColumnList(true); //设置生成代码的输出位置 globalConfig.setOutputDir(path+\"/src\"); //设置主键生成策略 Auto即是主键自增 globalConfig.setIdType(IdType.AUTO); //数据源配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setUrl(\"jdbc:mysql://localhost:3306/tingyu?useSSL=false&amp;userUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2D8\"); dataSourceConfig.setUsername(\"root\"); dataSourceConfig.setPassword(\"root\"); dataSourceConfig.setDriverName(\"com.mysql.jdbc.Driver\"); //包配置 生成的目录输出到哪一个包下 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent(\"com\") .setMapper(\"mapper\") .setService(\"service\") .setController(\"controller\") .setEntity(\"entity\") .setXml(\"mapper\"); //策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setCapitalMode(true) //是否设置全局大写命名 .setNaming(NamingStrategy.underline_to_camel) //设置表明和类名映射方式 .setTablePrefix(\"t_\") //设置表名前缀，生成代码时候对应类名会过滤掉前缀 .setInclude(\"t_admin\",\"t_admin_role\",\"t_company\", \"t_host\",\"t_host_power\",\"t_married_person\", \"t_menu\",\"t_order\",\"t_planner\",\"t_role\",\"t_role_menu\"); //指定要生成的表格名称，多个表继续传递即可，String类型的可变参数 //将定义好的配置信息传递到自动生成器 autoGenerator.setGlobalConfig(globalConfig); autoGenerator.setDataSource(dataSourceConfig); autoGenerator.setPackageInfo(packageConfig); autoGenerator.setStrategy(strategyConfig); //执行，生成代码 autoGenerator.execute(); }","link":"/2020/06/08/Java/AutoGeneratorCode/"},{"title":"xx05电影x","text":"xx05电影网静态逆向分析 12网络繁忙的可能性有两种：一可能是未设置延迟造成两个数据提交间隔过快不合理；二是可能缺少一条前置的访问数据。此app则需要提前访问一条数据解决繁忙问题：（http://m.mapps.m1905.cn/Recommendindex/home） request由图 对User/sendVer进行搜索找到如下 12345678910public void a(String arg7, int arg8) { StringBuilder v1 = new StringBuilder(); v1.append(\"http://m.mapps.m1905.cn/User/sendVer\"); v1.append(\"?request=\"); try { v1.append(URLEncoder.encode(aay.b(\"mobile=\" + arg7 + \"&amp;templateid=\" + arg8), \"UTF-8\")); } catch(UnsupportedEncodingException v0) { v0.printStackTrace(); } 进入aay.b后 1234567891011121314public static String b(String arg4) { String v0_2; try { SecretKey v0_1 = SecretKeyFactory.getInstance(\"DESede\").generateSecret(new DESedeKeySpec(aay.key.getBytes())); Cipher v1 = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\"); v1.init(1, ((Key)v0_1), new IvParameterSpec(aay.iv.getBytes())); v0_2 = aau.a(v1.doFinal(arg4.getBytes())); } catch(Exception v0) { v0_2 = \"\"; } return v0_2; } 得知是3DES加密并且获取了key和iv值；对请求链接加密内容jYgPer7AuEo3v%2BQTW6EduEpNaqgpgocriV8lbJ24PdQ%3D进行url解码得到jYgPer7AuEo3v+QTW6EduEpNaqgpgocriV8lbJ24PdQ=，然后再进行des解码 12345678910111213/* 此前放入CryptoJS.min.js加密库*/function test(data){ var key = CryptoJS.enc.Utf8.parse(\"iufles8787rewjk1qkq9dj76\"); var iv = CryptoJS.enc.Utf8.parse(\"vs0ld7w3\"); var res = CryptoJS.TripleDES.decrypt(data,key,{ iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return res.toString(CryptoJS.enc.Utf8);} 得到mobile=此处手机号&amp;templateid=1 响应文本内容也可用此方法进行解密。 key搜索key值找到如下 进入方法发现abh.a()是一个md5加密，再进去找abb.c()的值 发现此方法获取的是did的值，于是key的值便是对did+m1905_2014的MD5加密值","link":"/2020/08/12/android/xx05%E7%94%B5%E5%BD%B1x/"},{"title":"20200516 每日记录","text":"每日记录 1 mybatis映射文件中的autoMapping用处是什么 自动映射 2 多表联查 3 varStatus是&lt;c:forEach&gt;jstl循环标签的一个属性，varStatus属性。就拿varStatus=“status”来说，事实上定义了一个status名的对象作为varStatus的绑定值。该绑定值也就是status封装了当前遍历的状态，比如，可以从该对象上查看是遍历到了第几个元素：${status.count} 4 是第一次回调函数后的for循环中，如果你再次发送请求，for循环并不会停止，即使你写了同步请求也不行。 但是如果你在声明for循环变量用let后，代码会直到你请求完毕，回调函数执行完毕后，再进行下一次的循环。 这就考虑到了一个闭包的问题，如果你写var和let声明的作用域不同。 let i 会以局部变量的形式传递 var i 会以全局变量的形式传递 如果要想将 i 变量传递给下一层，要使用let 去声明。 5 判断几个选项是否有选择一项 （校验） 6 frameset标签不能和body共存 ？？？ FRAMESET 元素是 FRAME 元素的容器。HTML 文档可包含 FRAMESET 元素或 BODY 元素之一，而不能同时包含两者。 7 n+1 select语句的数目太多，需要频繁的访问数据库，会影响检索性能。如果需要查询n个Customer对象，那么必须执行n+1次select查询语句。这就是经典的n+1次select查询问题。 这种检索策略没有利用SQL的连接查询功能 8， forward和redirect的区别 forward 重定向: 1,重定向会改变浏览器地址栏地址 2,重定向不止可以访问服务器内的资源,还可以访问外部连接 3重定向因为是两次请求,所以重定向不能使用request来访问资源和共享数据,因为request的作用域是一次请求内, redirect 请求转发: 1,不会改变浏览器地址栏信息 2,只能访问服务器内部资源 3,是一次请求.所以可以使用request共享数据 9. resultMap标签 10 /** /* 是拦截所有的文件夹，不包含子文件夹 /** 是拦截所有的文件夹及里面的子文件夹","link":"/2020/06/04/diary/20200516%E8%AE%B0%E5%BD%95/"},{"title":"-我们自己才是我们需要不断去比较和竞争的对象-","text":"！用最少的时间做最高效的事！","link":"/2020/06/16/diary/Top/"},{"title":"mysql之DQL","text":"DQL(数据查询语言) 语法： 1select 列名(多列间逗号，全部列用*) from 表名 [where 过滤条件 group by 分组查询 having 分组后的过滤 order by 排序 limit 分页]; 1.简单的条件条件查询： 查询所有数据 1select * from student(表名) 带条件查询 可以使用的条件：&lt; , &lt;= , = , &gt; , &gt;= , != , &lt;&gt; , in , between…and… , and , or ,not , is null , like 。 1234567891011121314151617181920212223242526272829303132-- 查询编号为1004的学生的姓名和生日 select name,birthday from student where id=1004;-- 查询年龄大于18的学生信息 select * from student where age&gt;18;-- 查询小明的成绩 select name,score from student where name='小明';-- 查询年龄在18到20之间的所有学生 select * from student where age&gt;18 and age&lt;20; select * from student where age between 18 and 20; -- 查询除了1003外的所有学生信息 select * from student where id != 1003; select * from student where id &lt;&gt; 1003;-- 查询编号为1005或者年龄为18的学生信息 select * from student where id=1005 or age=18;-- 查询编号为1003和编号为1005的学生信息 select * from student where id=1003 and id=1005; select * from student where id in(1003,1005);-- 查询编号不是1003和1005的学生信息 select * from student where id not in(1003,1005);-- 查询所有姓张的学生信息, 可以使用like关键字进行模糊查询 --like关键字需要配合通配符使用 --通配符有两个: %(任意个任意字符), _(任意一个字符) select * from student where name like '张%';-- 查询名字中带国的学生信息 select * from student where name like '%国%';-- 查询名字第二个字符为明的学生信息 select * from student where name like '_明%';-- 查询缺考学生的信息, score没有值, 不是为0 select * from student where score is null;-- 查询没有缺考的学生信息 select * from student where score is not null; select * from student where not score is null; 2.select子句select子句的作用是选择要查询的列，还包括以下功能： 可以在select子句中进行运算； 可以用distinct过滤重复的行数据； 可以给列起别名。 123456789101112-- 运算 -- null不参与运算, 结果都是null select name,score,scoer+10 from student;-- 可以给列定义别名, 使用as关键字, 可以省略 -- 别名最好不要出现特殊字符, 中文也不建议使用 select name, score, score+10 as new_score from student; select name, score, score+10 new_score from student; select name, score, score+10 '成绩' from student; -- ifnull函数，类似于java中的三目运算符，用于处理空值null，如果某个字段为null，则使用给定的值进行替换 select name, score, IFNULL(score,0)+10 new_score from student; -- 查询所有学生的年龄 select distinct age from student; 3.排序使用order by子句可以进行结果的排序，需要配合两个关键字一起使用： ​ ASC ，升序 ，ascending （ 默认值 ） ​ DESC ，降序 , descending 。 1234567891011121314--查询所有学生信息，按照id进行升序排序 select * from student order by id asc;--查看年龄为20的学生信息，按照id降序排序 select * from student order by id desc;--可以按照别名进行排序--查询所有学生的新成绩，并按照新成绩排名 select name,score+10 new_score from student order by new_score desc;--order by 后可以写数字，代表第几列(一般不用) select * from student order by 6;--rand（）函数，生成随机数，范围是[0，1）--配合rand函数可以进行数据的随机排序，打乱数据,洗牌. select * from student order by rand();--查询所有学生的信息，按照年龄降序排序，如果年龄相同，再按照id降序排序 select * from student order by age desc,id desc; 4.分组函数分组函数用于对查询结果进行统计，共有5个，返回结果是一个值。count() ，sum()，max()，min()，avg()。 123456--分组函数使用时，null值不进行统计--统计所有学生的人数 select count(*) from student; select count(id) from student;--查询总分，最低分数和最高分数及平均分数 select sum(score),min(score),max(score),avg(score) from student; 5.分组查询分组查询使用group by子句实现，分组查询后需要注意以下几点： ​ 1.select子句只能查询分组字段和分组函数。 ​ 2.可以使用where在分组前条件过滤。 ​ 3.可以使用having在分组后进行条件过滤。 12345678-- 按照性别进行分组, 分别统计男女同学的人数和平均成绩 select gender,count(*) cnt,avg(score) avg_score from student group by gender;-- 按照性别进行分组，分别统计男女同学的人数和平均成绩，排除成绩低于70的学生信息 select gender,count(*) cnt,avg(score) avg_score from student where score&gt;=70 group by gender; -- 按照年龄进行分组，分别统计不同年龄同学的人数和平均成绩，排除人数小于2的分组信息-- where和having的区别在于where中无法使用分组函数，而having中可以使用 select age, count(*) cnt, avg(score) avg_score from student group by age having count(*)&gt;=2; select age, count(*) cnt, avg(score) avg_score from student group by age having cnt&gt;=2; 6.分页查询 MySQL中，可以通过limit关键词实现分页查询，limit是MySQL的特有语法，limit后面需要跟两个参数，第一个参数是查询的起始索引（从0开始），第二个参数是查询的记录数，limit必须出现在SQL的末尾。 12345678910--每页显示两条学生信息，完成分页显示--page：第几页--size：每页显示几条数据 select * from student order by id limit (page-1) * size, size;--第一页 select * from student order by id limit 0,2;--第二页 select * from student order by id limit 2,2;--第三页 select * from student order by id limit 4,2;","link":"/2020/06/03/mysql/mysq%E4%BA%8C%20DQL/"},{"title":"如何阅读一本书","text":"《如何阅读一本书》读书笔记 本书的开篇指出了任何一种阅读都是一种活动，因此必须要有一些主动的活力。很多人在阅读的时候，常常没读多久就开始出现双眼停滞、头脑昏睡的状况，这种精神不济的状态根本无法将阅读进行下去。作者认为，人们之所以出现这种现象，是因为阅读缺乏主动性。 完全被动的阅读只会越读越疲惫，越读越乏味，直至放弃阅读。所以，预备开始阅读的人首先要认识到的是：阅读是一件主动的事情，阅读越主动，效果越好。 既然阅读是一种活动，那么也必有活动的目的。阅读的目的可分为两种：第一种是为获得资讯而读，第二种是为求得理解而读。 阅读与自身知识水平相当的书，那么阅读的目的就只是为了获得这本书所载录的信息而已。阅读高于自身知识水平的书，并试图读懂读透它，向自己现有的理解力发起挑战，则是阅读的另一种目的——提升理解力。 这本书所针对的读者就是那些想把读书的主要目的当作是增进理解能力的人而写。在没有任何外力的帮助的情况下，只凭着内心的力量，玩味着眼前的字句，慢慢地提升自己，从只有模糊的概念到更清楚地理解为止。以一己之力来提升自我，从粗浅的了解推进到深入的理解，认知自我破茧而出。 好的阅读者应该具备敏锐的观察力、灵敏可靠的记忆、想象的空间，以及训练有素的分析、省思能力。然而并不是所有阅读的人都拥有这些阅读能力，但好在这些能力和技巧是可以通过学习和训练而获得的，答案和秘诀就藏在这本阅读圣经里。 01.如何把握一本书的基础架构并了解全书内容《如何阅读一本书》将阅读分为四个层次，分别是：基础阅读、检视阅读、分析阅读、主题阅读。之所以称作层次而不是方法或类别，是因为四个层次之间呈递进与包含的关系。也就是说，阅读的层次是渐进的。第二层阅读是建立在第一层阅读的基础上，而第三层由建立在第二层之上，而最高的层次第四层则包括了之前的所有阅读层次。 首先来了解阅读的第一个层次：基础阅读。这是阅读层次中最基础的一层，以识文断字为主要目的，阅读时能够清晰的知道作者是在说什么。这本书所针对的人群是已经至少具备基础阅读能力的阅读者。 第二个阅读层次是检视阅读。目的是在最短的时间内，对全书最好最重要的内容快速的阅读并掌握。这一层次是建立在读者已经具备第一层阅读能力的基础上，以增进理解力为目标的读者必须掌握这个层次的阅读方法。 检视阅读有两个阶段： 第一个阶段是有系统的略读或粗读，用最经济的方法了解一本书的架构，判断这本书值不值得花时间仔细阅读。拿到一本书，首先翻看书籍的书名页、 序、目录页、索引、出版者的介绍这些内容。挑选几个与主题相关的篇章阅读，留意主题的基本脉动，以及书籍结尾记载着作者自认为既新又重要的观点的三四页。 第二个阶段是粗浅的阅读，面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索，了解全书内容。 在完成检视阅读的过程中，读者要完成四个问题： （1）这本书到底在谈些什么？找出这本书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。 （2）作者详细说了什么，怎么说的？找出主要的想法、声明与论点。这些组合成作者想要传达的特殊讯息。 （3）这本书说得有道理吗？是全部有道理，还是部分有道理？阅读并理解了一本书后知道了作者的想法，还应该为这本书做个自己的判断。 （4）这本书跟你有什么关系？如果这本书给了你一些资讯，就要问问这些资讯有什么意义。如果这本书启发了你，就要找出相关的、更深的含意或建议，获得更多的启示。 回答完这四个问题，检视阅读的两个步骤就已经完成了。这时，关于一本书的基础架构和整体内容，你也已能做到心中有数了。但这还不是终点，没有经过阅读的第三个层次分析阅读，就不算真正理解一本书。 02.如何通过分析阅读读透一本书很多人在阅读会遇到无论花多长时间阅读、无论读的有多认真，却仍是无法参透一本书到底在讲什么的境况。这就好像是一个近在身边的人，无论花多长时间与其相处，却总是无法看透他。其实这并不是人难懂、书难懂，而是我们缺乏看透的能力。想要读透一本书，需要达到阅读的第三个层次——分析阅读。 分析阅读，目的是在较长的阅读时间内，对全书最好最重要的内容细嚼慢咽，反复咀嚼其深意。分析阅读就是全盘的阅读、完整的阅读，或是说优质的阅读，是读者能做到的最好的阅读方式。 分析阅读共分为三个阶段，在这个层次的阅读中，读者要紧抓住一本书，一直要读到这本书成为自己的一部分为止。 分析阅读的第一阶段：找出一本书在谈些什么。 （1）依照书的种类与主题来分类。你一定要知道自己在读的是哪一类书，最好在开始阅读之前就知道。一开始时，用检视阅读先浏览一遍，初步了解这本书。 （2）使用最简短的文字说明整本书在谈些什么。找出这本书的主题或重点，揣测这个作者想要做什么，说出本书的大意。 （3）将主要部分按顺序与关联性列举出来。将全书的大纲列举出来，并将各个部分的大纲也列出来。这一条强调了一本书的复杂性。一本完整的书也是一个完整的个体，当读者掌握了一本书的整体性时，便会立刻抓住其中重要的部分。而这些重要部分同样需要透视阅读，深入了解。 （4）确定作者想要解决的问题。一本书的作者在开始写作时一定是先有一个或多个问题的，而这本书的内容就是对于这些问题的答案。读者的责任就是从书中精确地找出这些问题来，并按照重要性整合出顺序。 这一阶段，读者可以回答对一本书提出来的第一个问题：这本书大体上来说是在谈论什么。 分析阅读的第二阶段：诠释一本书的内容规则。 （5）诠释作者的关键字，与他达成共识。找出那些举足轻重的单字，并确认这些单字在使用时的意义，诠释内容与信息。譬如作者用特殊方法来运用的一些字，或是作者强调的字，以及一些专门用语等。 （6）由最重要的句子中，抓住作者的重要主旨。最重要的句子是在整个论述中，阐述作者判断的部分。还有些重要的句子会出现在段落开头或结尾，类似学生时代学习的找文章的主旨句。 （7）知道作者的论述是什么，从内容中找出相关的句子，再重新架构出来。找出书中说明重要论述的段落，从相关段落中整理出前后顺序。 （8）找出作者的解答。确定作者已经解决了哪些问题，还有哪些是没解决的。再判断哪些是作者知道他没解决的问题。 这一阶段，读者可以回答对一本书提出来的第二个问题：这本书详细的内容是什么？作者是如何写出来的？ 分析阅读的第三阶段：像是沟通知识一样地评论一本书的规则。 阅读一本书是作者与读者之间的一场对话。读者对作者所教导的内容做出判断和评论，值得表扬或是提出批评。最能学习的读者，也就是最能批评的读者。读者必须懂得如何判断一本书，能在最后对一本书提出回应，对于作者所讨论的问题，努力整理出自己的想法。 A．智慧礼节的一般规则 （9）除非你已经完成大纲架构，也能诠释整本书了，否则不要轻易批评。在你说出：“我读懂了!”之前，不要说你同意、不同意或暂缓评论。同意或不同意都需要花心力来判断，而不是随意地盲目赞同或无礼批判。 （10）不要争强好胜，非辩到底不可。当你不同意作者的观点时，要理性地表达自己的意见，不要无理地辩驳或争论。此外，读者还应该为自己的观点找出理由来支撑。 （11）在说出评论之前，你要能证明自己区别得出真正的知识与个人观点的不同。尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。 B．批评观点的特别标准 当读者读懂了一本书，但是却不同意作者时，读者也可以不带偏见的就书中不认同作者的部分做出辩论。书中提出了四种站在作者对立角度来评论一本书的方法，在提出这四种评论时，读者应避免陷入情绪化或偏见的状态。 （12）证明作者的知识不足。意思是指作者缺少某些与他想要解决的问题相关的知识。 （13）证明作者的知识错误。意思是指作者的理念不正确，比如缺乏知识。 （14）证明作者不合逻辑。意思是指作者的推论荒谬，比如缺乏连贯性，或是前后矛盾。 （15）证明作者的分析与理由是不完整的。意思是指作者并没有解决他一开始提出来的所有问题，或是并没能善用他手边的资料，没有看出看出其间的含意与纵横交错的关系。 在提出这些评论之前，读者要注意的是，一本书不可能所有的内容都是知识不足或知识有误，也不可能全部内容都不合逻辑。要做出批评评论的读者要指出作者存在的问题，并为自己所说的话提出理由。 这个阶段，读者可以回答对一本书提出来的第三个与第四个问题：这是真实的吗？有意义吗？ 运用分析阅读三个阶段所提出的这些方法和规则，仔细地阅读一本书，而不是浮于表面地阅读大量的书，就是一个好读者能达到的理想境界了。 当然，许多书都值得精读。但有更多的书只要浏览一下就行了。要成为一个好读者，就要懂得依照一本书的特质，运用不同的阅读技巧来阅读。 03.阅读的最终目标：主题阅读阅读的最后也是最高的层次是主题阅读，即同时阅读数本讲述某种相似概念的书籍，总结归纳比较其中的概念，并从中提出超越这些数本中知识的新的想法。这是所有阅读中最复杂也最系统化的阅读。 在做主题阅读时，阅读者会读很多本书，列举出这些书之间相关之处，提出一个所有书都谈到的主题。借助这些书籍，主题阅读者要架构出一个或许在哪一本书里都没提过的主题分析。因此，主题阅读是最主动、最花费力气的一种阅读，但也是收效最大的一种阅读。 主题阅读中分为两个阶段： 一个是准备阶段的观察研究，针对你要研究的主题，设计一份试验性的书目，这时可以参考图书馆目录、专家的建议与书中的书目索引。浏览这份书目上所有的书，确定哪些与主题相关，并就这个主题建立起清楚的概念。 这是做主题阅读的准备工作，对一个特定的问题来说，所牵涉的绝不是一本书而已。因此，在开始之前要先确定好准备研究哪几本书。 另一个阶段就是正式进入主题阅读了，开始阅读第一阶段收集到的所有书籍。在这个阶段，前面提到的阅读第二层次——检视阅读，就是读者在做主题阅读时主要的工具或手段了。 （1）找到相关的章节。在主题阅读中，所确立的主题才是基本的重点，而不是所阅读的书。在这里，阅读的目的是解决问题，而非单纯的阅读这本书。因此，主题阅读的第一步应该是用检视阅读法确定好与主题相关的章节。 （2）带引作者与你达到共识。这一步应该由你来建立其共识，也就是说强迫作者使用你的语言，而不是他的语言。这套语言要能够帮助我们了解所有的作者，并能解决我们的问题。 （3）厘清问题。列出一些可以把我们的问题说得比较明白的问题，然后让作者来回答这些问题。问题的顺序与主题有关，内容涉及从正在研究的概念或现象，到这些概念或现象是如何被发现或表现出来的，最后到前面的这些问题会产生怎样的影响。在这一步，所有的作者，都应该能对这些问题做出回答。尽管答案可能不会相同，但这正也是后续一步所要做的事情。 （4）界定议题。将作者针对各个问题的不同意见整理陈列在各个议题之旁。各个作者之间或之中，不见得一定存在着某个议题。有时候，需要针对一些不是作者主要关心范围的事情，把他的观点解读，才能建构出这种议题。 （5）分析讨论。把问题和议题按顺序排列，以求突显主题。将比较有共通性的议题，放在比较没有共通性的议题之前。各个议题之间的关系也要清楚地界定出来。 至此，主题阅读就算完成了。前面说过，主题阅读是最为主动的阅读。阅读者基于某种困惑或是亟待解决的问题，主动的向书本求索答案。而这也就是将阅读当作了一种处世指南，用于指导我们的人生航路。 有一种很古老的测验，目的是帮人们找出对自己而言最有意义的书目。测验是这样的：如果你被警告将在一个无人荒岛度过余生，或至少很长的一段时间，而假设你有时间作一些准备，可以带一些实际有用的物品到岛上，还能带十本书去，你会选哪十本？ 列这样一份书单其实是很有指导性的，因为可以帮助你发现自己最想一读再读的书是哪些。当你想象自己被隔绝在一个没有娱乐、没有资讯、没有可以理解的一般事物的世界时，比较起来你是否会对自己了解得更多一点？这个与世隔绝的岛上没有电视也没有收音机，更没有图书馆，只有你跟十本书。 在某种程度上，现实中的我们跟被放逐到荒岛上的人没什么两样。我们面对的挑战都是如何找出内在的资源，过更美好的人类生活的挑战。 《如何阅读一本书》的作者认为，身体的成长是有限制的，心智的发展却没有限制。心智不会因为到了某个年纪死就停止成长，只有当大脑失去活力，僵化了，才会失去了增加技巧与理解力的力量。 主动的阅读，不只是对阅读本身有用，也不只是对我们的工作或事业有帮助，更能帮助我们的心智保持活力与成长。 任何一种超越基础阅读的阅读层次，其核心在于读者要努力提出问题，然后尽可能地找出答案。这是主动阅读中最重要的原则。 以增进理解力为目的读书，就要真正读懂一本书。要真正完全读懂一本书，就必须把这本书变成自己的一部分才行。 阅读是一辈子的事情，什么时候开始都不算晚，最重要的是开始","link":"/2020/06/11/other/readBook/"},{"title":"x715quan逆向协议分析","text":"x715quan逆向协议分析 获取到以下数据，从键值分析nonce，codeSign和access_token三个数值有加密 将apk放入JEB2进行分析 通过搜索调试定位到 nonce1234567891011protected void a(String arg11, JSONObject arg12, d arg13) { String v0 = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); long v2 = System.currentTimeMillis(); JSONObject v1 = this.a(arg12); if(MyApplication.getInstance().isLogin()) { g.a(arg11, new f[]{new f(\"user_id\", \"\" + MyApplication.getInstance().getUserDataEntity().getUid()), new f(\"login_token\", \"\" + MyApplication.getInstance().getUserDataEntity().getLogin_token()), new f(\"nonce\", v0), new f(\"codeSign\", v.a(v0, v1, MyApplication.getInstance().getUserDataEntity().getUid() + \"\", v2)), new f(\"timestamp\", v2 + \"\"), new f(\"data\", v1.toString()), new f(\"version\", a.f + \"\"), new f(\"product_version\", \"220\"), new f(\"platform\", Build.PRODUCT + \"\"), new f(\"network\", MyApplication.getNetworkType() + \"\"), new f(\"device\", \"\" + MyApplication.getDeviceId()), new f(\"access_token\", \"\" + a.h), new f(\"screen_width\", \"\" + a.i), new f(\"screen_height\", \"\" + a.j), new f(\"bbsnopic\", MyApplication.isForumNoIMG() + \"\"), new f(\"system\", \"2\"), new f(\"system_version\", Build$VERSION.SDK_INT + \"\"), new f(\"theme\", a.b + \"\")}, ((ResultCallback)arg13)); } else { g.a(arg11, new f[]{new f(\"nonce\", v0), new f(\"codeSign\", v.a(v0, v1, v2)), new f(\"timestamp\", v2 + \"\"), new f(\"data\", v1.toString()), new f(\"version\", a.f + \"\"), new f(\"product_version\", \"220\"), new f(\"platform\", Build.PRODUCT + \"\"), new f(\"network\", MyApplication.getNetworkType() + \"\"), new f(\"device\", \"\" + MyApplication.getDeviceId()), new f(\"access_token\", \"\" + a.h), new f(\"screen_width\", \"\" + a.i), new f(\"screen_height\", \"\" + a.j), new f(\"bbsnopic\", MyApplication.isForumNoIMG() + \"\"), new f(\"system\", \"2\"), new f(\"system_version\", Build$VERSION.SDK_INT + \"\"), new f(\"theme\", a.b + \"\")}, ((ResultCallback)arg13)); } } 可知nonce原为UUID，用replaceAll替换了“-”变为无符号的格式； codeSignif中 new f(“codeSign”, v.a(v0, v1, MyApplication.getInstance().getUserDataEntity().getUid() + “”, v2)), else中 new f(“codeSign”, v.a(v0, v1, v2)), v0：nonce的值 v1： 由new f(“data”, v1.toString())得知是数据中data的值 v2：当前时间戳 数据中的timestamp 进入v.a（）方法，获得如下 12345678910111213 public static String a(String arg3, JSONObject arg4, String arg5, long arg6) { return r.a(arg4.toString() + arg3 + v.a() + arg6 + arg5).toUpperCase(); } public static String a(String arg4, JSONObject arg5, long arg6) { return r.a(arg5.toString() + arg4 + v.a() + arg6).toUpperCase();} private static String a() { return v.a(af.b(2131230990), \"\"); } private static String a(String arg2, String arg3) { return af.a(arg2 + arg3, af.b(2131231233)); } 进入af.b方法： 1234567891011public static String b(int arg1) { String v0_1; try { v0_1 = MyApplication.getInstance().getResources().getString(arg1); } catch(Exception v0) { v0.printStackTrace(); v0_1 = \"\"; } return v0_1;} 根据方法可知2131230990和的2131231233值隐藏在资源文件中； 将数字转为16进制后再resources—values—public中搜索7f08010e 找到 根据类型在strings.xml中找到同名变量： 94ac5cfb69e87bd7 同理获得2131231233的资源值是：860f50db3569e448 进入af.a方法中 123public static String a(String arg2, String arg3) { return new StringBuffer(arg2 + arg3).reverse().toString();} 两个参数相加并reverse可得：844e9653bd05f0687db78e96bfc5ca49 进入r.a可知是md5加密，所以结果是 (data+nonce+844e9653bd05f0687db78e96bfc5ca49+timestamp).toUpperCase(); access_token new f(“access_token”, “” + a.h) 进入a.h后得到 a.h = r.a(v0); String v0 = a.f + Build.PRODUCT + MyApplication.getNetworkType() + MyApplication.getDeviceId(); 此时也可使用log输出获得v0的值 在apk用解压工具打开，移动出classes.dex并在逆向助手中反编译dex，根据上面这个方法的包名获取地址package com.quan0715.forum.b;在a.smali中找到了此方法，对照这个变量下面添加 invoke-static {v0}, Lcrack;-&gt;log(Ljava/lang/String;)V 然后将crack.smali放入dex根目录，再重新用逆向助手重打包，并替换apk中的dex文件并重新安装此apk；如果apk安装失败重新签名即可。 打开ddms 获取此应用的log信息 由log信息获得v0的值是version+platform+network+device； 然后进行md5加密即可得token值","link":"/2020/06/06/android/x715quan%E9%80%86%E5%90%91%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"title":"mysql 基础知识及DDL,DML","text":"MYSQL基础 cmd操作指令：mysql -u用户名 -p密码 -h主机地址 -P端口号 -u ：user -p ：password 隐式输入无需在-p后加密码 -h ：host 默认是localhost -P ：port mysql默认是3306 定义 SQL： Structured Query language 结构化查询语言 规范 一条语句要以分号（;）结束 sql可以单行和多行书写，一般通过缩进和换行书写提高代码可读性 sql的关键词一般都要全大写 分类 DDL（Data Defination Language） 数据定义语言 用于操作数据库常用对象，例如数据库 表格等，常用的关键字：CREATE（创建）； ALTER（修改） ； DROP（删除）等 DML（Data Manipulation Language）数据操作语言 用于对表格进行增删改操作，常用关键字：INSERT（增） ； DELETE（删） ； UPDATE （改）等 DQL（Data Query Language） 数据查询语言 用于对表格进行查询操作 ，常用关键字： SELECT（查） ； WHERE（条件） ； FROM（位置）等 DCL（Data Control Language） 数据控制语言 用于对权限的控制 ，常用关键字 ： GRANT(授权) REVOKE（撤销） 操作Database12查看所有的databaseshow databases; 创建database - 直接创建：create database 名称; - 指定编码方式创建： create database 名称 character set utf8; - 如果数据库不存在则创建：create database if not exists 名称;使用database - use 数据库名 修改database - alter database 名称 character set gbk;删除database - 直接删除：drop database 名称; - 如果存在则删除：drop database if exists 名称; 操作table*1.查询当前database下所有可用的table * 1show tables; 2.mysql中常用的数据类型 在MySQL中，有三种主要类型：Text（文本），Number（数字），Date/Time（日期/时间）类型。 Text类型： 常用类型： CHAR(size) ：括号中指定字符串长度，最多255个字符。不可变字符串，性能好，但占用空间是固定的。 VARCHAR(size)：括号中指定字符串长度，最多255个字符可变字符串，如果长度大于255则被转换为TEXT类型。可变字符串性能差，但占用空间是可变的。 TEXT ：不需要指定长度，用于存放大文本数据。 Number类型 常用类型： INT(size)：括号中指定最大位数。4个字节。 TINYINT(size)：-128到127。0到255 无符号。括号中指定最大位数。1个字节，如果长度为1，通常用于表示boolean，1-&gt;true, 0-&gt;false。 BIGINT(size)：括号中指定最大位数，8个字节。 FLOAT(size,d)：size指定最大位数，d指定小数点右侧的最大位数。存放带有浮动小数点的小数字，4个字节。 DOUBLE(size,d)：size指定最大位数，d指定小数点右侧的最大位数。存放带有浮动小数点的大数字，8个字节。 Date/Time类型：常用类型：DATE() ：格式：YYYY-MM-DD 年月日。DATE() ：格式：YYYY-MM-DD HH : MM : SS 年月日时分秒。3.创建表格 123456789create table 表名 （ 列名 列类型， 列名 列类型， 列名 列类型）; 4.查看表格结构 1desc 表名字； 5.修改表格 修改表名 alter table 原表名 rename to 新表名； 修改字段（列）的类型 alter table 表名 modify 列名 类型； 修改字段名 alter table 表名 change 原列名 新列名 类型； 增加字段 alter table 表名 add（列名 类型，....）; 删除字段 alter table 表名 drop column 列名; 6.删除表格 1drop table [if exists] 表名; DML操作新增数据： 1insert into (列名1，列名2，列名3) values (值1，值2，值3); 列和值要一一对应,多个数据逗号隔开。 列可以省略，表示所有的列都要增加数据 数据的类型要和列的类型一致，除了数字以外，其他数据都需要加引号（单引号或双引号） 修改数据 1update 表名 set 列1=值1，列2=值2 [where 条件]; 删除数据 12dalete from 表名 [where 条件]; 效率低可回滚。truncate table 表名; 如果要删除整个表的数据，建议使用truncate。效率高不可回滚。","link":"/2020/06/02/mysql/mysql-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8ADDL-DML/"},{"title":"vpy加密视频破解转mp4-JAVA代码实现","text":"vpy加密视频破解转mp4-JAVA代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import java.io.*;import java.nio.file.Files;public class TestHex { /** * 文件转字节数组 * @param filePath * @return * @throws IOException */ public static byte[] fileToByte(String filePath) throws IOException { byte[] bFile = Files.readAllBytes(new File(filePath).toPath()); return bFile; } /** * 16进制string转字节数组 * @param str * @return */ public static byte[] toBytes(String str) { if(str == null || str.trim().equals(\"\")) { return new byte[0]; } byte[] bytes = new byte[str.length() / 2]; for(int i = 0; i &lt; str.length() / 2; i++) { String subStr = str.substring(i * 2, i * 2 + 2); subStr=xor(subStr,\"05\"); bytes[i] = (byte) Integer.parseInt(subStr, 16); } return bytes; } /** * 测试字节数组完整性 #取消 * @param str */ public static void writerFile(String str) { BufferedWriter bw = null; try { File file = new File(\"C:\\\\Users\\\\qqq\\\\Desktop\\\\新建文件夹\\\\test.txt\"); /* 先创建文件*/ if (!file.exists()) { file.createNewFile(); } FileWriter fw = new FileWriter(file); bw = new BufferedWriter(fw); bw.write(\"\"); bw.write(str); System.out.println(\"写入成功\"); } catch (IOException ioe) { ioe.printStackTrace(); } finally { try { if(bw != null){ bw.close();} } catch (Exception ex) { System.out.println(\"Error in closing the BufferedWriter\" + ex); } } } /** * 异或 * @param strHex_X * @param strHex_Y * @return */ private static String xor(String strHex_X,String strHex_Y){ //将x、y转成二进制形式 String anotherBinary=Integer.toBinaryString(Integer.valueOf(strHex_X,16)); String thisBinary=Integer.toBinaryString(Integer.valueOf(strHex_Y,16)); String result = \"\"; //判断是否为8位二进制，否则左补零 if(anotherBinary.length() != 8){ for (int i = anotherBinary.length(); i &lt;8; i++) { anotherBinary = \"0\"+anotherBinary; } } if(thisBinary.length() != 8){ for (int i = thisBinary.length(); i &lt;8; i++) { thisBinary = \"0\"+thisBinary; } } //异或运算 for(int i=0;i&lt;anotherBinary.length();i++){ //如果相同位置数相同，则补0，否则补1 if(thisBinary.charAt(i)==anotherBinary.charAt(i)) { result += \"0\"; }else{ result+=\"1\"; } } return Integer.toHexString(Integer.parseInt(result, 2)); } /** * 字节数组转文件 * @param bytes * @param filePath * @param fileName */ public static void getFileByBytes(byte[] bytes, String filePath, String fileName) { BufferedOutputStream bos = null; FileOutputStream fos = null; File file = null; try { File dir = new File(filePath); if (!dir.exists() &amp;&amp; dir.isDirectory()) {// 判断文件目录是否存在 dir.mkdirs(); } file = new File(filePath + \"\\\\\" + fileName); fos = new FileOutputStream(file); bos = new BufferedOutputStream(fos); bos.write(bytes); } catch (Exception e) { e.printStackTrace(); } finally { if (bos != null) { try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 字节数组转16进制String * @param bytes * @return */ public static String bytesToHexFun3(byte[] bytes) { StringBuilder buf = new StringBuilder(bytes.length * 2); for(byte b : bytes) { // 使用String的format方法进行转换 buf.append(String.format(\"%02x\", new Integer(b &amp; 0xff))); } return buf.toString(); } /** * 主方法 * @param beforeFilePath 原始文件目录 * @param filePath 转换完成后的文件目录 * @param fileName 转换完成后的新文件名 * @throws Exception */ public static void vpyToMP4(String beforeFilePath,String filePath,String fileName) throws Exception { //获取文件初始字节数组 byte[] arr = fileToByte(beforeFilePath); //获取字节数组中的16进制字符串 String hexStr = bytesToHexFun3(arr); //截取050505后的16进制 hexStr = hexStr.substring(hexStr.indexOf(\"050505\"), hexStr.length()); //转换回字节数组 byte[] bytes = toBytes(hexStr); getFileByBytes(bytes, filePath, fileName); System.out.println(fileName+\"-----转换完成\"); }}","link":"/2020/06/04/share/vpy%E5%8A%A0%E5%AF%86%E8%A7%86%E9%A2%91%E7%A0%B4%E8%A7%A3%E8%BD%ACmp4-JAVA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"title":"X果","text":"X果逆向协议分析 tokenurl中的token大多是前面请求返回的而不是生成的。 对url中间部分进行搜索找到token的位置如下 12345678910111213141516171819202122232425262728293031323334method static constructor &lt;clinit&gt;()V .registers 400000000 const/4 v3, 000000002 const/4 v0, 400000004 new-array v0, v0, [String00000008 const-string v1, &quot;http://mapi.yiguo.com/MobileApi.aspx?token=CA0C4043E9594934BB51BCE0AD9D36EB&amp;v=&quot;0000000C aput-object v1, v0, v300000010 const/4 v1, 100000012 const-string v2, &quot;http://devtest.yiguo.com:8086/MobileApi.aspx?token=819934DD44CB4359B167C352EA473BCA&amp;v=&quot;00000016 aput-object v2, v0, v10000001A const/4 v1, 20000001C const-string v2, &quot;http://172.17.7.227:8086/MobileApi.aspx?token=819934DD44CB4359B167C352EA473BCA&amp;v=&quot;00000020 aput-object v2, v0, v100000024 const/4 v1, 300000026 const-string v2, &quot;http://premapi.yiguo.com/MobileApi.aspx?token=CA0C4043E9594934BB51BCE0AD9D36EB&amp;v=&quot;0000002A aput-object v2, v0, v10000002E sput-object v0, c-&gt;b:[String00000032 new-instance v0, StringBuilder00000036 invoke-direct StringBuilder-&gt;&lt;init&gt;()V, v00000003C sget-object v1, c-&gt;b:[String00000040 aget-object v1, v1, v300000044 invoke-virtual StringBuilder-&gt;append(String)StringBuilder, v0, v10000004A move-result-object v00000004C const-string v1, &quot;4.3.0&quot;00000050 invoke-virtual StringBuilder-&gt;append(String)StringBuilder, v0, v100000056 move-result-object v000000058 const-string v1, &quot;&amp;os=android&amp;sign=&quot;0000005C invoke-virtual StringBuilder-&gt;append(String)StringBuilder, v0, v100000062 move-result-object v000000064 invoke-virtual StringBuilder-&gt;toString()String, v00000006A move-result-object v00000006C sput-object v0, c-&gt;a:String00000070 return-void.end method 如上token应该是固定值 UserName和Password1234567891011121314151617181920212223public static f a(String arg4, String arg5, String arg6) { f v0 = new f(); try { v0.a().a(\"yiguo.mapi.user.login\"); v0.b().putOpt(\"UserName\", ac.a(arg4)); v0.b().putOpt(\"Password\", ac.a(arg5)); v0.b().putOpt(\"AdChannelName\", arg6); String v1 = d.p(v0.c()); if(v1 == null) { return null; } return new f(v1); } catch(Exception v0_1) { v0_1.printStackTrace(); } catch(JSONException v0_2) { v0_2.printStackTrace(); } return null; } 搜索找到如上，进入username和password的加密函数， 12345678910111213public static String b(String arg6) { String v0_1; if(arg6 == null || (arg6.equals(\"\"))) { v0_1 = \"\"; } else { Cipher v0 = Cipher.getInstance(\"AES/CBC/PKCS7Padding\"); v0.init(1, new SecretKeySpec(e.a(\"879FC8CB80958B9599C1CADF9F979B9A8190CBCC8E9F8B9198C0CADE9F939E9B8F\", new String(e.b)).getBytes(\"utf-8\"), \"AES\"), new IvParameterSpec(e.a(\"879BCDCC84918B9099C4CADF9A979E9F859AC7C98F978C9098C7C8D99E9D959F84\", new String(e.b)).getBytes(\"utf-8\"))); v0_1 = b.a(v0.doFinal(arg6.getBytes(\"utf-8\"))); } return v0_1; } 分析发现密钥并未提交给服务器，所以密钥是静态的即服务器已有，而不是动态的。 既然是静态的只需要获得key和iv即可，进行动态调试就可以获得这两项，再进行aes 的解密即可。 url中的sign一般数据包的签名在最后执行，所以sign的运算在UserName和Password之后。 在 String v1 = d.p(v0.c());中的d.p找到可能性函数，进入获得 12345678910111213141516171819public static String a(String arg5) { try { MessageDigest v0_3 = MessageDigest.getInstance(\"MD5\"); v0_3.update(arg5 + e.a(\"879BCDCC81918B9099C4CADF9F979E9F859ECDC984918E9099C1CFDA9A979E9A8599CCC882948A9198C7CBDE9D979899879BC8CE83938A9192C0C9D99F979F9585\", new String(e.b)).getBytes(\"utf-8\")); String v0_4 = e.a(v0_3.digest()).toLowerCase(); return v0_4; } catch(Exception v0) { v0.printStackTrace(); } catch(UnsupportedEncodingException v0_1) { v0_1.printStackTrace(); } catch(NoSuchAlgorithmException v0_2) { v0_2.printStackTrace(); } return \"\"; } 是一个md5加密并且在原提交数据包内容中加了后缀，因为并未对后缀进行数据传输，服务器获取不到客户端的后缀现值，因此排除动态后缀的可能性。同样进行动态调试找到后缀的值即可。","link":"/2020/08/20/android/X%E6%9E%9C/"}],"tags":[{"name":"C","slug":"C","link":"/tags/C/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ssm","slug":"ssm","link":"/tags/ssm/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","link":"/tags/MyBatisPlus/"},{"name":"Android逆向","slug":"Android逆向","link":"/tags/Android%E9%80%86%E5%90%91/"},{"name":"协议分析","slug":"协议分析","link":"/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"name":"每日记录","slug":"每日记录","link":"/tags/%E6%AF%8F%E6%97%A5%E8%AE%B0%E5%BD%95/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术分享","slug":"技术分享","link":"/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"categories":[{"name":"C","slug":"C","link":"/categories/C/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"Android逆向","slug":"Android逆向","link":"/categories/Android%E9%80%86%E5%90%91/"},{"name":"每日记录","slug":"每日记录","link":"/categories/%E6%AF%8F%E6%97%A5%E8%AE%B0%E5%BD%95/"},{"name":"知识小记","slug":"C/知识小记","link":"/categories/C/%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"ssm","slug":"java/ssm","link":"/categories/java/ssm/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"协议分析","slug":"Android逆向/协议分析","link":"/categories/Android%E9%80%86%E5%90%91/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"name":"技术分享","slug":"技术分享","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"ssm","slug":"每日记录/ssm","link":"/categories/%E6%AF%8F%E6%97%A5%E8%AE%B0%E5%BD%95/ssm/"}]}